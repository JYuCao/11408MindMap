# 排序
## 内部排序
### 插入排序
#### 直接插入排序(Direct Insertion Sort)
- 时间复杂度
    - 最好情况：O(n)，输入数据**全部有序（最合适）**
    - 最坏情况：O(n^2)，输入数据完全逆序
    - 平均情况：O(n^2)
- 空间复杂度：O(1)
- 稳定性：true
- 适用性：适用于顺序存储和链式存储结构，链式存储无需移动元素（更合适）
- 特征：
    1. a趟排序后，前a个记录是有序的
    2. 最后一趟排序前，可能所有元素都不在最终位置上

#### 折半插入排序(Binary Insertion Sort)
- 时间复杂度：
    - 最好情况：O(nlogn)
    - 最坏情况：O(n^2)
    - 平均情况：O(n^2)
- 空间复杂度：O(1)
- 稳定性：true
- 适用性：适用于顺序存储结构，对数据量不大的排序表表现较好

#### 希尔排序（Shell Sort）
- 时间复杂度：
    - 最好情况：O(nlogn)
    - 最坏情况：O(n^2)
    - 平均情况：O(n^1.3)
- 空间复杂度：O(1)
- 稳定性：false
- 适用性：仅适用于顺序存储结构

### 交换排序
#### 冒泡排序（Bubble Sort）
- 时间复杂度：
    - 最好情况：O(n)，输入数据**全部有序（最合适）**
    - 最坏情况：O(n^2)，输入数据完全逆序
    - 平均情况：O(n^2)
- 空间复杂度：O(1)
- 稳定性：true
- 适用性：适用于顺序存储和链式存储结构
- 特征：
    1. 每趟排序都能确定一个元素的最终位置
    2. 最终要进行一次无交换扫描以确定排序结束

#### 快速排序（Quick Sort）
- 时间复杂度：
    - 最好情况：O(nlogn)
    - 最坏情况：O(n^2)，每次划分都极不平衡
    - 平均情况：O(nlogn)
- 空间复杂度：递归调用栈空间
    - 最好情况：O(logn)
    - 最坏情况：O(n)
    - 平均情况：O(logn)
- 稳定性：false
- 适用性：适用于顺序存储结构
- 特征：
    1. 每趟排序都能确定一个元素的最终位置，但不一定是按顺序确定的
    2. 快速排序是所有内部排序算法中平均性能最优的算法s-+

### 选择排序
#### 简单选择排序（Simple Selection Sort）
- 时间复杂度：O(n^2)，比较次数始终为n(n-1)/2
- 空间复杂度：O(1)
- 稳定性：false
- 适用性：适用于顺序存储和链式存储结构，以及关键字较少的记录排序
- 特征：
    1. 每趟排序都能确定一个元素的最终位置
    2. 比较次数与初始排列无关

#### 堆排序（Heap Sort）
- 大根堆满足A[i]>=A[2i]且A[i]>=A[2i+1]，小根堆满足A[i]<=A[2i]且A[i]<=A[2i+1]
- 堆逻辑结构满足完全二叉树
- 建堆（大根堆为例）：
    - 从最后一个非叶子节点（$\lfloor n/2 \rfloor$）开始，将其与左右子节点中**较大**的节点交换
    - **递归调整**被交换节点的子树，直到根节点
- 输出堆顶：将堆顶元素与**堆的最后一个元素**交换，堆的长度减1，对新的堆顶进行递归调整
- 堆的插入：将新元素插入堆的最后位置，然后**自下向上**调整堆
- **时间复杂度：建堆：O(n)，调整（插入、输出）为O(logn)，排序时间：O(nlogn)**
- 空间复杂度：O(1)
- 稳定性：false
- 适用性：适用于顺序存储结构，对大规模数据排序较为有效

### 二路归并排序（Binary Merge Sort）
- 时间复杂度：O(nlogn)
- 空间复杂度：O(n)
- 稳定性：true
- 适用性：适用于顺序和链式存储结构
- 特征：
    1. 对于k路归并排序，时间复杂度为O($nlog_kn$)

### 基数排序（Radix Sort）
- 最高位优先法（MSD）排序结果为从大到小，最低位优先法（LSD）排序结果为从小到大
- 时间复杂度：O(d(n+r))，d为关键字位数，r为每个位上可能的取值范围（一次分配：O(n)，收集：O(r)）
- 空间复杂度：O(r)（r个队列）
- 稳定性：true
- 适用性：适用于顺序和链式存储结构

### 计数排序（Counting Sort）
- 时间复杂度：O(n+k)，k为关键字的取值范围
- 空间复杂度：O(n+k)
- 稳定性：true
- 适用性：更适用于顺序结构，对关键字取值范围较小的排序表表现较好

### 部分结论
- 在排序过程中，每趟都能确定一个元素的最终位置的排序算法有：冒泡排序、快速排序、堆排序、简单选择排序、堆排序
- 稳定性：
    - 不稳定的算法有：希尔排序、快速排序、堆排序、简单选择排序
    - 稳定的算法有：插入排序、冒泡排序、归并排序、基数排序
- 时间复杂度：
    - O(n^2)的排序算法有：简单选择排序、直接插入排序、冒泡排序
    - O(nlogn)的排序算法有：归并排序（始终）、堆排序、快速排序
    - 最好情况为O(n)的排序算法有：直接插入排序、冒泡排序
    - 最坏情况为O(n^2)的排序算法有：直接插入排序、冒泡排序、快速排序
- 与序列初始状态无关的排序算法有：简单选择排序、堆排序
- 存储结构：
    - 适用于顺序存储和链式存储结构的排序算法有：直接插入排序、冒泡排序、简单选择排序、归并排序、基数排序
    - 仅适用于顺序存储结构的排序算法有：折半插入排序、希尔排序、快速排序、堆排序

### 表格
| 排序算法       | 时间复杂度（最好） | 时间复杂度（最坏） | 时间复杂度（平均） | 空间复杂度 | 稳定性 | 适用性                     |
| -------------- | ------------------ | ------------------ | ------------------ | ---------- | ------ | ---------------------------- |
| 直接插入排序   | O(n)               | O(n^2)             | O(n^2)             | O(1)       | true   | 顺序和链式       |
| 折半插入排序   | O(nlogn)          | O(n^2)             | O(n^2)             | O(1)       | true   | 顺序                 |
| 希尔排序       | O(nlogn)          | O(n^2)             | O(n^1.3)           | O(1)       | false  | 顺序                 |
| 冒泡排序       | O(n)               | O(n^2)             | O(n^2)             | O(1)       | true   | 顺序和链式       |
| 快速排序       | O(nlogn)          | O(n^2)             | O(nlogn)          | **O(logn)**   | false  | 顺序                 |
| 简单选择排序   | O(n^2)             | O(n^2)             | O(n^2)             | O(1)       | false  | 顺序和链式      |
| 堆排序         | O(nlogn)          | O(nlogn)          | O(nlogn)          | O(1)       | false  | 顺序                 |
| 二路归并排序   | O(nlogn)          | O(nlogn)          | O(nlogn)          | **O(n)**       | true   | 顺序和链式       |
| 基数排序       | O(d(n+r))         | O(d(n+r))         | O(d(n+r))         | **O(r)**       | true   | 顺序和链式       |

## 外部排序
### 知识点
- 指在内存容量有限的情况下，对大量数据进行排序的方法
- 以减少磁盘I/O次数为主要目标：增大归并路数，减少归并段数
- 利用败者树增大归并路数
- 利用置换-选择排序增大归并长度并减少归并段数
- 最佳归并树：由长度不等的归并段进行多路平衡归并

### 败者树
- 可视为完全二叉树
- 构造：
    1. 叶子节点存放各归并段的**当前元素**
    2. 非叶子节点存放其两个子节点中**较大元素的下标**
    3. 最终根节点存放**最小元素的下标**
- 维护：
    1. 将刚输出的叶子节点与其父节点比较，更新父节点
    2. 依次向上比较，直到根节点
- 特点：消除了内部归并中元素个数k对归并效率的影响

### 置换-选择排序
- 生成初始归并段：
    1. 输入文件FI，工作区WA，输出文件FO
    2. 从FI中读入w个记录到WA，每次选择WA中最小的记录标记为MINIMAX（利用败者树）
    3. 将MINIMAX输出到FO中
    4. 从FI中读入下一个记录
    5. 从WA中所有比MINIMAX大的记录中选择最小的记录作为新的MINIMAX
    6. 重复步骤3-5，直到WA中找不到比FO中最后输出记录更大的记录为止，输出归并段结束标志
    7. 重复步骤2-6，直到FI中所有记录读完

### 最佳归并树
- 本质上是m叉树的哈夫曼树，WPL代表磁盘I/O次数
- 构造：
    1. 将所有归并段的长度作为叶子节点
    2. 选择m个权值最小的节点作为m叉树的子节点，生成一个新节点，其权值为m个子节点权值之和
    3. 重复步骤2，直到所有节点合并为一棵m叉树
- 若归并段数不足m的整数倍，可添加若干长度为0的“虚段”

