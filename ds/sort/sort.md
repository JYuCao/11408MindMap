# 排序
## 内部排序
### 插入排序
#### 直接插入排序(Direct Insertion Sort)
- 时间复杂度
    - 最好情况：O(n)，输入数据**全部有序（最合适）**
    - 最坏情况：O(n^2)，输入数据完全逆序
    - 平均情况：O(n^2)
- 空间复杂度：O(1)
- 稳定性：true
- 适用性：适用于顺序存储和链式存储结构，链式存储无需移动元素（更合适）
- 特征：
    1. a趟排序后，前a个记录是有序的
    2. 最后一趟排序前，可能所有元素都不在最终位置上

#### 折半插入排序(Binary Insertion Sort)
- 时间复杂度：
    - 最好情况：O(nlogn)
    - 最坏情况：O(n^2)
    - 平均情况：O(n^2)
- 空间复杂度：O(1)
- 稳定性：true
- 适用性：适用于顺序存储结构，对数据量不大的排序表表现较好

#### 希尔排序（Shell Sort）
- 时间复杂度：
    - 最好情况：O(nlogn)
    - 最坏情况：O(n^2)
    - 平均情况：O(n^1.3)
- 空间复杂度：O(1)
- 稳定性：false
- 适用性：仅适用于顺序存储结构

### 交换排序
#### 冒泡排序（Bubble Sort）
- 时间复杂度：
    - 最好情况：O(n)，输入数据**全部有序（最合适）**
    - 最坏情况：O(n^2)，输入数据完全逆序
    - 平均情况：O(n^2)
- 空间复杂度：O(1)
- 稳定性：true
- 适用性：适用于顺序存储和链式存储结构
- 特征：
    1. 每趟排序都能确定一个元素的最终位置
    2. 最终要进行一次无交换扫描以确定排序结束

#### 快速排序（Quick Sort）
- 时间复杂度：
    - 最好情况：O(nlogn)
    - 最坏情况：O(n^2)，每次划分都极不平衡
    - 平均情况：O(nlogn)
- 空间复杂度：递归调用栈空间
    - 最好情况：O(logn)
    - 最坏情况：O(n)
    - 平均情况：O(logn)
- 稳定性：false
- 适用性：适用于顺序存储结构
- 特征：
    1. 每趟排序都能确定一个元素的最终位置，但不一定是按顺序确定的
    2. 快速排序是所有内部排序算法中平均性能最优的算法

## 外部排序

## 部分结论
- 在排序过程中，每趟都能确定一个元素的最终位置的排序算法有：冒泡排序、快速排序、堆排序、简单选择排序
- 不稳定的算法有：希尔排序、快速排序、堆排序、简单选择排序
- 平均时间复杂度为O(nlogn)的排序算法有：归并排序、堆排序、快速排序
